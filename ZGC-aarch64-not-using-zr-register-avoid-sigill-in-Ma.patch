From 425112071e77e2fb599d1f96ce48689d45461261 Mon Sep 17 00:00:00 2001
Date: Mon, 17 Feb 2020 18:55:47 +0800
Subject: [PATCH] ZGC: aarch64: not using zr register avoid sigill in
 MacroAssembler::push_fp and pop_fp

Summary: <gc>: <instruction ldp doesn't support two same register>
LLT: jtreg
Bug url: NA
---
 src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp | 46 +++++++++++++---------
 1 file changed, 24 insertions(+), 22 deletions(-)
diff --git a/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp b/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp
index 611f13b0e..6db979b57 100644
--- a/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp
@@ -2100,57 +2100,59 @@ int MacroAssembler::pop(unsigned int bitset, Register stack) {
 // Push lots of registers in the bit set supplied.  Don't push sp.
 // Return the number of words pushed
 int MacroAssembler::push_fp(unsigned int bitset, Register stack) {
-  int words_pushed = 0;
-
   // Scan bitset to accumulate register pairs
   unsigned char regs[32];
   int count = 0;
+  int i = 0;
   for (int reg = 0; reg <= 31; reg++) {
     if (1 & bitset)
       regs[count++] = reg;
     bitset >>= 1;
   }
-  regs[count++] = zr->encoding_nocheck();
-  count &= ~1;  // Only push an even number of regs
 
-  // Always pushing full 128 bit registers.
-  if (count) {
-    stpq(as_FloatRegister(regs[0]), as_FloatRegister(regs[1]), Address(pre(stack, -count * wordSize * 2)));
-    words_pushed += 2;
+  if (!count) {
+    return 0;
   }
-  for (int i = 2; i < count; i += 2) {
+
+  add(stack, stack, -count * wordSize * 2);
+
+  if (count & 1) {
+    strq(as_FloatRegister(regs[0]), Address(stack));
+    i += 1;
+  }
+
+  for (; i < count; i += 2) {
     stpq(as_FloatRegister(regs[i]), as_FloatRegister(regs[i+1]), Address(stack, i * wordSize * 2));
-    words_pushed += 2;
   }
 
-  assert(words_pushed == count, "oops, pushed != count");
   return count;
 }
 
 int MacroAssembler::pop_fp(unsigned int bitset, Register stack) {
-  int words_pushed = 0;
-
   // Scan bitset to accumulate register pairs
   unsigned char regs[32];
   int count = 0;
+  int i = 0;
   for (int reg = 0; reg <= 31; reg++) {
     if (1 & bitset)
       regs[count++] = reg;
     bitset >>= 1;
   }
-  regs[count++] = zr->encoding_nocheck();
-  count &= ~1;
 
-  for (int i = 2; i < count; i += 2) {
-    ldpq(as_FloatRegister(regs[i]), as_FloatRegister(regs[i+1]), Address(stack, i * wordSize * 2));
-    words_pushed += 2;
+  if (!count) {
+    return 0;
   }
-  if (count) {
-    ldpq(as_FloatRegister(regs[0]), as_FloatRegister(regs[1]), Address(post(stack, count * wordSize * 2)));
-    words_pushed += 2;
+
+  if (count & 1) {
+    ldrq(as_FloatRegister(regs[0]), Address(stack));
+    i += 1;
   }
 
-  assert(words_pushed == count, "oops, pushed != count");
+  for (; i < count; i += 2) {
+    ldpq(as_FloatRegister(regs[i]), as_FloatRegister(regs[i+1]), Address(stack, i * wordSize * 2));
+  }
+
+  add(stack, stack, count * wordSize * 2);
 
   return count;
 }
