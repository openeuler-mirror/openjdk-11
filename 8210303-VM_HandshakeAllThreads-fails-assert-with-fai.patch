From 06c663befa33d4a71faed3f58ae47faab753b658 Mon Sep 17 00:00:00 2001
Date: Sat, 28 Mar 2020 12:00:06 +0000
Subject: [PATCH] 8210303 VM_HandshakeAllThreads fails assert with "failed:
 blocked and not walkable"

Summary: <gc>: <vmthread can process handshake in more conditions>
LLT: jdk11u/test/hotspot/jtreg/vmTestbase/nsk/jvmti/scenarios/sampling/SP07/sp07t002/TestDescription.java
Bug url: https://bugs.openjdk.java.net/browse/JDK-8210303
---
 src/hotspot/share/runtime/handshake.cpp | 25 +++++++++++++++++++++++--
 1 file changed, 23 insertions(+), 2 deletions(-)

diff --git a/src/hotspot/share/runtime/handshake.cpp b/src/hotspot/share/runtime/handshake.cpp
index 7aac489..1891623 100644
--- a/src/hotspot/share/runtime/handshake.cpp
+++ b/src/hotspot/share/runtime/handshake.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -343,6 +343,27 @@ bool HandshakeState::vmthread_can_process_handshake(JavaThread* target) {
   return SafepointSynchronize::safepoint_safe(target, target->thread_state());
 }
 
+static bool possibly_vmthread_can_process_handshake(JavaThread* target) {
+  // An externally suspended thread cannot be resumed while the
+  // Threads_lock is held so it is safe.
+  // Note that this method is allowed to produce false positives.
+  assert(Threads_lock->owned_by_self(), "Not holding Threads_lock.");
+  if (target->is_ext_suspended()) {
+    return true;
+  }
+  switch (target->thread_state()) {
+  case _thread_in_native:
+    // native threads are safe if they have no java stack or have walkable stack
+    return !target->has_last_Java_frame() || target->frame_anchor()->walkable();
+
+  case _thread_blocked:
+    return true;
+
+  default:
+    return false;
+  }
+}
+
 bool HandshakeState::claim_handshake_for_vmthread() {
   if (!_semaphore.trywait()) {
     return false;
@@ -362,7 +383,7 @@ void HandshakeState::process_by_vmthread(JavaThread* target) {
     return;
   }
 
-  if (!vmthread_can_process_handshake(target)) {
+  if (!possibly_vmthread_can_process_handshake(target)) {
     // JT is observed in an unsafe state, it must notice the handshake itself
     return;
   }
-- 
1.8.3.1

